#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    steerPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  frontSonar,     sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  backSonar,      sensorSONAR_inch)
#pragma config(Motor,  port2,           lDrive1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           lDrive2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lDrive3,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           steer1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           steer2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rDrive3,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rDrive2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rDrive1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rkControl/slewLim.h"

typedef struct {
	int target,
		val,
		error,
		out;
	float kP,
		kI,
		kD;
} Pid;

Pid potSteer;

void setDrive(int pwr) {
	motor[lDrive1] =
		motor[lDrive2] =
		motor[lDrive3] =
		motor[rDrive1] =
		motor[rDrive2] =
		motor[rDrive3] =
		mtrSlew(lDrive1, pwr, 15);
}

void initPid(Pid *pid, float kP, float kI, float kD) {
	pid->kP = kP;
	pid->kI = kI;
	pid->kD = kD;
}

void setPid(Pid *pid, int targ) {
	pid->target = targ;
}

task steerCtl() {
	static float prop,
		integ,
		deriv;
	static int errorLast;

	while(true) {
		errorLast = potSteer.error;

		potSteer.val = SensorValue[steerPot];
		potSteer.error = potSteer.target - potSteer.val;

		prop = potSteer.error * potSteer.kP;

		integ += potSteer.error * potSteer.kI;
		if(abs(integ) > 127)
			integ = 127 * sgn(integ);

		deriv = (potSteer.error - errorLast) * potSteer.kD;

		motor[steer1] =
			motor[steer2] =
			potSteer.out =
			prop + integ + deriv;

		wait1Msec(20);
	}
}

task main()
{

	int potTarg,
		drivePwr;

	startTask(steerCtl);

	initPid(&potSteer, .1, .001, .01);

	while(true) {
		potTarg = (abs(vexRT[Ch1]) >= 7) ? vexRT[Ch1] * 13 : 0;
		drivePwr = (abs(vexRT[Ch3]) >= 15) ? vexRT[Ch3] : 0;

		if(drivePwr > 0) {
			if(SensorValue[frontSonar] <= 15) {
				drivePwr = (drivePwr * 15) / SensorValue[frontSonar];
				if(SensorValue[frontSonar] <= 9)
					drivePwr = 0;
			}
		}

		else if(drivePwr < 0) {
			if(SensorValue[backSonar] <= 15) {
				drivePwr = (drivePwr * 15) / SensorValue[backSonar];
				if(SensorValue[backSonar] <= 9)
					drivePwr = 0;
			}
		}

		setDrive(drivePwr);
		setPid(&potSteer, potTarg);

		wait1Msec(20);
	}
}
