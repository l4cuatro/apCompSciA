#pragma config(StandardModel, "RVW CLAWBOT")
#pragma config(RenamedStdModelMotor, port1, lWheel)
#pragma config(RenamedStdModelMotor, port6, claw)
#pragma config(RenamedStdModelMotor, port7, arm)
#pragma config(RenamedStdModelMotor, port10, rWheel)
#pragma config(RenamedStdModelSensor, in1, lLine)
#pragma config(RenamedStdModelSensor, in2, midLine)
#pragma config(RenamedStdModelSensor, in3, rLine)
#pragma config(RenamedStdModelSensor, dgtl1, rWheelEnc)
#pragma config(RenamedStdModelSensor, dgtl3, lWheelEnc)
#pragma config(RenamedStdModelSensor, dgtl6, touch)
#pragma config(RenamedStdModelSensor, dgtl8, sonar)
#pragma config(RenamedStdModelSensor, dgtl11, armEnc)
#pragma config(RenamedStdModelSensor, I2C_1, rWheelIme)
#pragma config(RenamedStdModelSensor, I2C_2, lWheelIme)
#pragma config(RenamedStdModelSensor, I2C_3, armIme)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("JoystickSimple")

#include "JoystickDriver.c"

typedef struct {
	int targ[2],
		val[2],
		valLast[2],
		err,
		out;
	float kP,
		kI,
		kD,
		prop,
		integ,
		integLim,
		deriv;
} Pid;

typedef struct {
	float deriv;
	int dt,
		val,
		valLast;
} Diff;

float diff(Diff* diff, int val, int dt) {
	diff->valLast = diff->val;
	diff->val = val;
	diff->deriv = (diff->val - diff->valLast) / dt;
	return diff->deriv;
}

typedef struct {
	float member[10],
		mean;
} Avg;

float upAvg(Avg* avg, float in) {
	avg->mean = 0;
	for(int i = 9; i > 0; i--) {
		avg->member[i] = avg->member[i-1];
		avg->mean += avg->member[i];
	}
	avg->member[0] = in;
	avg->mean += avg->member[0];
	return avg->mean;
}

float avg(float in1, float in2) {
	return (in1 + in2) / 2;
}

float pythag(float a, float b) {
	return sqrt(
		pow(a, 2)
		+ pow(b, 2)
	);
}

void initPid(Pid* pid, float kP, float kI, float kD, float integLim = 127) {
	pid->kP = kP;
	pid->kI = kI;
	pid->kD = kD;
	pid->integLim = integLim;
	pid->integ = 0;
}

void newPidTarg(Pid* pid, float targX, float targY) {
	pid->targ[0] = targX;
	pid->targ[1] = targY;
	pid->integ = 0;
}

int updatePid(Pid* pid, float x, float y, int dt = 20) {
	pid->valLast[0] = pid->val[0];
	pid->valLast[1] = pid->val[1];
	pid->val[0] = x;
	pid->val[1] = y;
	pid->err = pythag(
		(pid->targ[0] - pid->val[0]),
		(pid->targ[1] - pid->val[1])
	);
	pid->prop = pid->err * pid->kP;
	pid->integ += pid->err * pid->kI;
	pid->integ =
		(fabs(pid->integ) > pid->integLim)
		? pid->integ
		: pid->integLim * sgn(pid->integ);
	pid->deriv = (pid->val - pid->valLast) * pid->kD * 20 / dt;

	pid->out = (int) round(pid->prop + pid->integ + pid->deriv);
	return pid->out;
}

void setLDrive(int pwr) {
	motor[lWheel]
		= pwr;
}

void setRDrive(int pwr) {
	motor[rWheel]
		= pwr;
}

void arcCtl(int y, int rot) {
	setLDrive(y + rot);
	setRDrive(y - rot);
	return;
}

Pid drivePid,
	gyroPid;

Diff lDriveDiff,
	rDriveDiff;

Avg driveVelAvg;

float x = 0,
	y = 0,
	theta = 0;

task posTrack() {
	static int timeLast,
		time,
		dt,
		thetaLast,
		gyroVal,
		lEnc,
		rEnc;

	while(1) {
		thetaLast = gyroVal;
		timeLast = time;
		gyroVal = SensorValue[gyro];
		time = nSysTime;
		dt = time - timeLast;
		lEnc = SensorValue[lEnc];
		rEnc = SensorValue[rEnc];

		upAvg(&driveVelAvg,
			avg(diff(&lDriveDiff, lEnc, dt),
				diff(&rDriveDiff, rEnc, dt)
			)
		);

		if((fabs(gyroVal - thetaLast) / dt) > SensorBias[gyro])
			theta += (gyroVal - thetaLast);
		x += driveVelAvg.mean * dt * sinDegrees(theta);
		y += driveVelAvg.mean * dt * cosDegrees(theta);
	}
}

task ctls() {
	float dx,
		dy;
	int time,
		timeLast,
		dt;
	while(1) {
		timeLast = time;
		time = nSysTime;
		dt = time - timeLast;
		if(time - timeLast > 0) {
			updatePid(&drivePid, driveVelAvg.mean, dt);
			updatePid(&gyroPid, theta, dt);
		}
		wait1Msec(20);
	}
}

task main() {
	int ly,
		lx;
	bool driverCtl;
	bool btn5Last;

	SensorFullCount[gyro] = 21600;

	startTask(posTrack);
	startTask(ctls);

	initPid(&drivePid, .1, .001, .01);
	initPid(&gyroPid, .2, .002, .02);

	while(1) {
		getJoystickSettings(joystick);

		if(joy1Btn(5) && !btn5Last)
			driverCtl = !driverCtl;
		btn5Last = joy1Btn(5);

		ly = (fabs(joystick.joy1_y1) >= 15)
			? joystick.joy1_y1
			: 0;

		lx = (fabs(joystick.joy1_x1) >= 15)
			? joystick.joy1_x1
			: 0;

		if(driverCtl)
			arcCtl(ly, lx);
		else
			arcCtl(drivePid.out, gyroPid.out);

		wait1Msec(20);
	}
}
